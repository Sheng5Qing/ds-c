# 数据结构与算法
## 图的应用
### 最短路径
#### Dijkstra算法
##### 基本思想
>1. 指定源点u
>2. 结点集合V被划分为两个部分：集合S和集合V-S，S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而V-S则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。
>3. 初始时，集合S中仅包含u，最短路径长度为0。集合V-S所包含的结点到源点的最短路径待定，称从源点出发只经过集合S中的结点到达集合V-S的结点的路径为特殊路径，并用数组dist[]记录每个结点所对应的最短特殊路径的长度

就是用贪心算法，依次找两点之间的最短路径，由于当前顶点到源点已为当前最短路径，借由当前顶点为跳板找到的最短路径亦为当前最短路径。

#### 算法步骤
>1. 数据结构：带权邻接矩阵G.arc[][]；一维数组dist[i]记录源点到结点i的最短路径长度；一位数组p[i]记录最短路径上结点i的前驱
>2. 初始化：源点为u，则对于集合V-S中的所有结点i，dist[i] = G.arc[u][i]；若源点与结点i之间有路径相连，则初始化p[i] = u，否则p[i] = -1
>3. 找最小：在集合V-S中查找令dist[t]最小的结点t，则结点t就是集合V-S中离源点最近的结点，将其加入集合S中，同时更新V-S
>4. 若V-S为空，则算法结束，否则转向5
>5. 找跳板：对于集合V-S中的所有结点j ，都有可能借由j走捷径。若dist[j] > dist[t] + G.arc[t][j]，则令dist[j] = dist[t] + G.arc[t][j]，同时更新结点j的前驱结点为t，即p[j] = t。转向步骤3

#### Floyd算法
##### 基本思想
>在结点i和结点j之间插入结点k，看看是否可以缩短结点i与结点j之间的距离（松弛操作）
##### 算法步骤
>1. 数据结构：带权邻接矩阵G.arc[][]；最短距离数组dist[i][j],记录结点i到j的最短路径长度；前驱数组path[i][j]，记录从结点i到结点j的最短路径上结点j的前驱
>2. 初始化：初始化dist[i][j] = G.arc[i][j]；如果从结点i到结点j有边相连，则初始化path[i][j] = i，否则为1
>3. 松弛：在结点i、j之间插入结点k，看是否可以缩短结点i、j间的距离